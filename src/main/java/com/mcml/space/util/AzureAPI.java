package com.mcml.space.util;

import static com.mcml.space.util.VersionLevel.isPaper;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import org.apache.commons.lang.StringUtils;
import org.bukkit.Bukkit;
import org.bukkit.Sound;
import org.bukkit.command.CommandSender;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.permissions.Permission;
import org.bukkit.plugin.java.JavaPlugin;

import com.google.common.base.Predicate;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.mcml.space.core.EscapeLag;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;

/**
 * @author SotrForgotten, Vlvxingze
 */
public abstract class AzureAPI {
    /**
     * Cached prefix for every message
     */
    private static String loggerPrefix;
    
    /**
     * Server view distance (squared, both sides) in chunks
     */
    private static final int squaredViewDistanceChunk = (Bukkit.getViewDistance() * 2) ^ 2 + 1;
    
    /**
     * Server view distance (direct, single side) in blocks
     */
    private static final int viewDistanceBlock = Bukkit.getViewDistance() * 16;
    
    /**
     * Cached server thread instance
     */
    private static Thread serverThread;
    
    /**
     * Get cached server thread instance, lookup it if not have a cache yet
     * @return the main thread
     */
    @Nonnull
    public static Thread serverThread() {
        if (serverThread != null) return serverThread;
        for (Thread t : Thread.getAllStackTraces().keySet()) {
            if (t.getName().equals("Server thread")) return (serverThread = t);
        }
        throw new AssertionError("Cannot find main thread!");
    }
    
    /**
     * Coord stores chunk x and z as primitive int
     */
    @Getter
    @EqualsAndHashCode
    @AllArgsConstructor
    public static class ChunkCoord {
        final int chunkX;
        final int chunkZ;
    }
    
    /**
     * Creates a chunk coord by chunk x and z (performs >> 4 by a block pos)
     * @param chunkX
     * @param chunkZ
     * @return chunk coord
     */
    public static ChunkCoord wrapCoord(int chunkX, int chunkZ) {
        return new ChunkCoord(chunkX, chunkZ);
    }
    
    /**
     * Get the standard view distance from player, server value if current server not supporting custom value
     * @param player
     * @return
     */
    public static int viewDistance(Player player) {
        return customViewDistance(player) ? player.getViewDistance() : Bukkit.getViewDistance();
    }

    /**
     * Get view distance (direct, single side) in block from player, server value if current server not supporting custom value
     * @param player
     * @return
     */
    public static int viewDistanceBlock(Player player) {
        if (customViewDistance(player)) return player.getViewDistance() * 16;
        return viewDistanceBlock;
    }
    
    /**
     * Get view distance (squared, both sidess) in chunk from player, server value if current server not supporting custom value
     * @param player
     * @return has
     */
    public static int viewDistanceChunk(Player player) {
        if (customViewDistance(player)) return (player.getViewDistance() * 2) ^ 2 + 1;
        return squaredViewDistanceChunk;
    }
    
    /**
     * Check if the player has a custom view distance from player, false if current server not supporting custom value
     * @param player
     * @return has
     */
    public static boolean customViewDistance(Player player) {
        if (player == null || !isPaper()) return false;
        return player.getViewDistance() != Bukkit.getViewDistance();
    }
    
    /**
     * Set given prefix, the prefix will be appended before every message, set as null to reset.
     * @param prefix
     * @return colornized prefix
     */
    public static String setPrefix(String prefix) {
        loggerPrefix = (prefix = StringUtils.replaceChars(prefix, '&', 'ยง'));
        return prefix;
    }
    
    /**
     * Reset the prefix, i.e set to null.
     */
    public static void resetPrefix() {
        loggerPrefix = null;
    }
    
    /**
     * Concat the prefix with the context in the fastest way (according from benchmarks)
     * @param prefix
     * @param context
     * @return the prefixed context
     */
    public static String prefix(String prefix, String context) {
        return prefix == null ? context : prefix.concat(context);
    }
    
    /**
     * Send a severe level message to console with global prefix and disable the plugin
     * @param context
     * @param plugin
     */
    public static void fatal(String context, JavaPlugin plugin) {
        fatal(loggerPrefix, context, plugin);
    }
    
    /**
     * Send a severe level message to console with given prefix and disable the plugin
     * @param prefix
     * @param context
     * @param plugin
     */
    public static void fatal(String prefix, String context, JavaPlugin plugin) {
        Bukkit.getLogger().severe(prefix(prefix, context));
        Bukkit.getPluginManager().disablePlugin(plugin);
    }
    
    /**
     * Send a warning level message to console with global prefix
     * @param context
     */
    public static void warn(String context) {
        warn(loggerPrefix, context);
    }
    
    /**
     * Send a warning level message to console with given prefix
     * @param context
     */
    public static void warn(String prefix, String context) {
        Bukkit.getLogger().log(Level.WARNING, prefix(prefix, context));
    }
    
    /**
     * Send a info level message to console with global prefix
     * @param context
     */
    public static void log(String context) {
        log(loggerPrefix, context);
    }
    
    /**
     * Send a info level message to console with given prefix
     * @param prefix
     * @param context
     */
    public static void log(String prefix, String context) {
        Bukkit.getConsoleSender().sendMessage(prefix(prefix, context));
    }
    
    /**
     * Send a message to the sender with global prefix
     * @param sender
     * @param context
     */
    public static void log(CommandSender sender, String context) {
        log(sender, loggerPrefix, context);
    }
    
    /**
     * Send a message to the sender with given prefix
     * @param sender
     * @param prefix
     * @param msg
     */
    public static void log(CommandSender sender, String prefix, String context) {
        sender.sendMessage(prefix(prefix, context));
    }
    
    /**
     * Broadcast a message with global prefix
     * @param context
     */
    public static void bc(String context) {
        bc(loggerPrefix, context);
    }
    
    /**
     * Broadcast a message with global prefix and placing the placeholders
     * @param context
     */
    public static void bc(String context, String placeholder, String value) {
        bc(loggerPrefix, context, placeholder, value);
    }
    
    /**
     * Broadcast a message with given prefix and placing the placeholders
     * @param context
     */
    public static void bc(String prefix, String context, String placeholder, String value) {
        bc(prefix, StringUtils.replace(context, placeholder, value));
    }
    
    /**
     * Broadcast a message with given prefix
     * @param context
     */
    public static void bc(String prefix, String context) {
        Bukkit.broadcastMessage(prefix(prefix, context));
    }
    
    /**
     * Converts a time to standard (20 per seconds) ticks
     * @param unit time unit
     * @param duration
     * @return in ticks
     */
    public static long toTicks(TimeUnit unit, long duration) {
        return unit.toSeconds(duration) * 20;
    }
    
    /**
     * Creates a coord that wraps the given objects
     * @param key
     * @param value
     * @return
     */
    public static <K, V> Coord<K, V> wrapCoord(K key, V value) {
        return new Coord<K, V>(key, value);
    }
    
    /**
     * Coord stores key and value data
     * @param <K> first object
     * @param <V> second object
     */
    @Getter
    @EqualsAndHashCode
    @AllArgsConstructor
    public static class Coord<K, V> {
        final K key;
        final V value;
    }
    
    /**
     * Creates a coord that wraps the given objects
     * @param key
     * @param value
     * @param extra
     * @return
     */
    public static <K, V, E> Coord3<K, V, E> wrapCoord(K key, V value, E extra) {
        return new Coord3<K, V, E>(key, value, extra);
    }
    
    /**
     * Coord stores key and value, extra data
     * @param <K> first object
     * @param <V> second object
     * @param <E> third object
     */
    @Getter
    @EqualsAndHashCode
    @AllArgsConstructor
    public static class Coord3<K, V, E> {
        final K key;
        final V value;
        final E extra;
    }
    
    /**
     * Creates a case insensitive map
     * @return
     */
    public static <E> Map<String, E> newCaseInsensitiveMap() {
        return newCaseInsensitiveMap(false);
    }
    
    /**
     * Creates a case insensitive map, maybe thread safe
     * @return
     */
    public static <E> Map<String, E> newCaseInsensitiveMap(boolean concurrent) {
        return new CaseInsensitiveMap<E>(concurrent);
    }
    
    /**
     * Creates a case insensitive set
     * @return
     */
    public static Set<String> newCaseInsensitiveSet() {
        return newCaseInsensitiveSet(false);
    }
    
    /**
     * Creates a case insensitive set, maybe thread safe
     * @return
     */
    public static Set<String> newCaseInsensitiveSet(boolean concurrent) {
        return Sets.newSetFromMap(AzureAPI.<Boolean>newCaseInsensitiveMap(concurrent));
    }
    
    /**
     * Returns elements from the start, the edge included, collects to a list with immutable capacity. Respects the standard list index.
     * @param list
     * @param start
     * @param end
     * @return
     */
    public static <E> List<E> matchElements(List<E> list, int start) {
        return matchElements(list, start, list.size() - 1);
    }
    
    /**
     * Returns elements between the start and end index, the edge included, collects to a list with immutable capacity. Respects the standard list index.
     * @param list
     * @param start
     * @param end
     * @return
     */
    public static <E> List<E> matchElements(List<E> list, int start, int end) {
        List<E> t = Lists.newArrayListWithCapacity(end - start + 1);
        for (; start <= end; start++) {
            t.add(list.get(start));
        }
        return t;
    }
    
    /**
     * Contacts strings from the start, included the edge as well. Respects the standard list index.
     */
    public static String concatsBetween(List<String> list, int start, char spilt) {
        return concatsBetween(list, start, spilt);
    }
    
    /**
     * Contacts strings from the start, included the edge as well, then spilt by the given string. Respects the standard list index.
     */
    public static String concatsBetween(List<String> list, int start, String spilt) {
        return concatsBetween(list, start, list.size() - 1, spilt);
    }
    
    /**
     * Contacts strings between the start and end index, included the edge as well, then spilt by the given char. Respects the standard list index.
     */
    public static String concatsBetween(List<String> list, int start, int end, char spilt) {
        return concatsBetween(list, start, end, spilt);
    }
    
    /**
     * Contacts strings between the start and end index, included the edge as well, then spilt by the given string. Respects the standard list index.
     */
    public static String concatsBetween(List<String> list, int start, int end, String spilt) {
        String concated = "";
        for (; start <= end; start++) {
            concated = concated.concat(list.get(start).concat(start == end ? "" : spilt));
        }
        return concated;
    }
    
    /**
     * Check whether the sender has specified permission, ignore ops
     * @param sender
     * @param perm
     * @return
     */
    public static boolean hasPerm(CommandSender sender, String perm) {
        return sender.hasPermission(perm);
    }
    
    /**
     * Check whether the player has specified permission, false if cannot find, ignore ops
     * @param username
     * @param perm
     * @return
     */
    public static boolean hasPerm(String username, String perm) {
        Player player = Bukkit.getPlayer(username);
        return player == null ? false : player.hasPermission(perm);
    }
    
    /**
     * Check whether the sender has specified permission, ignore ops
     * @param sender
     * @param perm
     * @return
     */
    public static boolean hasPerm(CommandSender sender, Permission perm) {
        return sender.hasPermission(perm);
    }
    
    /**
     * Try to load a config, creates an empty one if not exist
     * @param file
     * @return
     */
    public static FileConfiguration loadOrCreateConfiguration(File file) {
        try {
            file = createDirectories(file);
            file.createNewFile();
        } catch (IOException ex) {
            AzureAPI.fatal("Cannot create file '" + file.getPath() + "', blocked?", EscapeLag.plugin);
            ex.printStackTrace();
        }
        return YamlConfiguration.loadConfiguration(file);
    }
    
    /**
     * Fixes a file that name contains path, transfer them to its path
     * @param file
     * @return
     */
    public static File fixesFilePath(File file) {
         return StringUtils.contains(file.getName(), "/") || StringUtils.contains(file.getName(), "\\") ?
                 new File(
                         StringUtils.substringBeforeLast(fixesPathSeparator(file.getPath()), "\\") + "\\" + StringUtils.substringBeforeLast(fixesPathSeparator(file.getName()), "\\"), // fixed patch
                         StringUtils.substringAfterLast(fixesPathSeparator(file.getName()), "\\")) // fixed name
                : file;
    }
    
    /**
     * Replaces '/' to '\'
     * @param path
     * @return
     */
    public static String fixesPathSeparator(String path) {
        return StringUtils.replace(path, "/", "\\");
    }
    
    /**
     * Try to create the parent directories for the file
     * @param file
     * @return
     */
    public static File createDirectories(File file) {
        file = fixesFilePath(file);
        new File(StringUtils.substringBeforeLast(fixesPathSeparator(file.getPath()), "\\")).mkdirs();
        return file;
    }
    
    /**
     * Try to restart server, false if not supports
     * @param message
     * @return
     */
    public static boolean restartServer(String message){
        if (!VersionLevel.isSpigot()) return false;
        PlayerList.forEach(new Predicate<Player>() {
            @Override
            public boolean apply(Player player) {
                player.kickPlayer(prefix(loggerPrefix, message));
                return true;
            }
        });
        org.spigotmc.RestartCommand.restart();
        return true;
    }
    
    /**
     * Plays a private sound at the player location
     * @param player
     * @param sound
     */
    public static void playSound(Player player, Sound sound) {
        playSound(player, sound, false);
    }
    
    /**
     * Plays a public sound at the player location
     * @param player
     * @param sound
     */
    public static void playSound(Player player, Sound sound, boolean broadcast) {
        if (broadcast) {
            player.getWorld().playSound(player.getLocation(), sound, 10F, 1F);
        } else {
            player.playSound(player.getLocation(), sound, 10F, 1F);
        }
    }
    
    /**
     * Try to colornize the element, no-op if not supports
     * @param element
     * @param type
     * @return
     */
    @SuppressWarnings("unchecked")
    public static <E> E colorzine(E element, Class<E> type) {
        if (element instanceof String) return (E) StringUtils.replaceChars((String) element, '&', 'ยง');
        
        if (element instanceof String[]) {
            String[] array = (String[]) element;
            for (int i = 0; i < array.length; i++) array[i] = StringUtils.replaceChars(array[i], '&', 'ยง');
            return (E) array;
        }
        
        if (element instanceof List) {
            List<String> c = (List<String>) element;
            for (String each : c) c.set(c.indexOf(each), StringUtils.replaceChars(each, '&', 'ยง'));
            return (E) c;
        }
        
        if (element instanceof Set) {
            Set<String> c = (Set<String>) element;
            for (String each : c) c.add(StringUtils.replaceChars(each, '&', 'ยง'));
            return (E) c;
        }
        
        return element;
    }
}
